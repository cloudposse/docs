---
title: "Setup ECS with Atmos"
sidebar_label: "Setup"
sidebar_position: 10
description: "Setup guide for deploying containerized applications to ECS with Atmos and OpenTofu"
---
import Intro from '@site/src/components/Intro';
import KeyPoints from '@site/src/components/KeyPoints';
import Steps from '@site/src/components/Steps'
import Step from '@site/src/components/Step'
import StepNumber from '@site/src/components/StepNumber'
import Note from '@site/src/components/Note'
import Admonition from '@theme/Admonition'
import TaskList from '@site/src/components/TaskList'

<Intro>
  This setup guide walks you through deploying containerized applications to AWS ECS Fargate using Atmos for configuration orchestration and OpenTofu for infrastructure-as-code. The setup uses a self-contained approach where application infrastructure definitions and workflows reside in the application repository, while shared infrastructure is managed in the infra repository.
</Intro>

## Overview

| Step | Action | Repository |
| ---- | ------ | ---------- |
| 1. Deploy platform infrastructure | Deploy VPC, ECS cluster, GitHub OIDC Provider, ALB, etc. | `infra` |
| 2. Provision tfstate-bucket-app | Create Terraform state bucket for app repos (if not exists) | `infra` |
| 3. Create application repository | Create repo from [cloudposse-examples/app-on-ecs-v2](https://github.com/cloudposse-examples/app-on-ecs-v2) template | GitHub |
| 4. Provision ECR registry | Add ECR image repository for the app | `infra` |
| 5. Provision IAM roles | Create IAM roles for the app to assume | `infra` |
| 6. Update tfstate-bucket-app access | Grant IAM roles access to state bucket | `infra` |
| 7. Update profiles/github | Configure GitHub OIDC roles in app repo | `app` |
| 8. Configure GitHub repository | Add `ECR_REGISTRY` variable | GitHub UI |
| 9. Provision shared dependencies | Deploy app dependencies (databases, queues, etc.) | `infra` |
| 10. Configure dependencies | Set up remote state for infra components | `app` |
| 11. Configure container definitions | Define ECS task and container settings | `app` |
| 12. Test configuration | Run `atmos terraform plan app -s preview` | `app` |

<Steps>
  <Step>
    ### <StepNumber/> Deploy Platform Infrastructure

    Deploy the foundational infrastructure components in your `infra` repository.

    Ensure the following components are deployed in your target AWS accounts:

    ```bash
    # Deploy VPC
    atmos terraform deploy vpc -s plat-use1-dev
    atmos terraform deploy vpc -s plat-use1-staging
    atmos terraform deploy vpc -s plat-use1-prod

    # Deploy ECS Cluster
    atmos terraform deploy ecs/cluster -s plat-use1-dev
    atmos terraform deploy ecs/cluster -s plat-use1-staging
    atmos terraform deploy ecs/cluster -s plat-use1-prod

    # Deploy Github OIDC Provider
    atmos terraform deploy github-oidc-provider -s plat-gbl-dev
    atmos terraform deploy github-oidc-provider -s plat-gbl-staging
    atmos terraform deploy github-oidc-provider -s plat-gbl-prod
    ```

    <Admonition type="info" title="Platform Infrastructure">
      These components are typically deployed once and shared across multiple applications. See the [ECS Cluster](/components/library/aws/ecs/) documentation for detailed setup instructions.
    </Admonition>
  </Step>

  <Step>
    ### <StepNumber/> Provision tfstate-bucket-app

    Create a Terraform state bucket for application repositories if one doesn't exist.

    In your `infra` repository, add the tfstate bucket configuration:

    ```yaml title="stacks/catalog/tfstate-backend/apps.yaml"
    components:
      terraform:
        tfstate-backend-apps:
          metadata:
            component: tfstate-backend
          vars:
            enabled: true
            name: tfstate-backend-apps
            # Additional configuration as needed
    ```

    Deploy tfstate bucket:

    ```bash
    atmos terraform deploy tfstate-bucket-apps -s plat-use1-dev
    atmos terraform deploy tfstate-bucket-apps -s plat-use1-staging
    atmos terraform deploy tfstate-bucket-apps -s plat-use1-prod
    ```
  </Step>

  <Step>
    ### <StepNumber/> Create Application Repository

    Create a new repository from the [cloudposse-examples/app-on-ecs-v2](https://github.com/cloudposse-examples/app-on-ecs-v2) template.

    <Steps>
      1. Navigate to [cloudposse-examples/app-on-ecs-v2](https://github.com/cloudposse-examples/app-on-ecs-v2)
      2. Click "Use this template" → "Create a new repository"
      3. Choose a name for the repository (e.g., `acme/example-app`)
      4. Select "Private" for repository visibility
      5. Click "Create repository"
    </Steps>

    The template includes:
    - Sample Go application with Dockerfile
    - GitHub Actions workflows for CI/CD
    - Terraform/OpenTofu components for ECS task definitions
    - Atmos stack configurations for each environment
  </Step>

  <Step>
    ### <StepNumber/> Provision ECR Registry

    Add an ECR image repository for the new application.

    In your `infra` repository, update the ECR component configuration:

    ```yaml title="stacks/catalog/ecr.yaml"
    components:
      terraform:
        ecr:
          vars:
            images:
              - acme/example-app
            # Additional configuration as needed
    ```

    ```bash
    atmos terraform deploy ecr -s core-use1-artifacts
    ```
  </Step>

  <Step>
    ### <StepNumber/> Provision IAM Roles

    Create IAM roles that the application will assume for deployments.

    Create an IAM role configuration for the application:

    ```yaml title="stacks/catalog/iam-role/example-app.yaml"
    import:
      - catalog/iam-role/defaults

    components:
      terraform:
        example-app/iam-role:
          metadata:
            component: iam-role
            inherits:
              - iam-role/defaults
          vars:
            name: example-app
            attributes:
              - "terraform"
            role_description: |
              Role for GitHub Actions to access the GitOps resources, such as the S3 Bucket and DynamoDB Table.
            github_oidc_provider_enabled: true
            github_oidc_provider_arn: !terraform.state github-oidc-provider oidc_provider_arn
            trusted_github_org: acme
            trusted_github_repos:
              - example-app
            policy_statements:
              AllowECRAccess:
                effect: "Allow"
                actions:
                  - "ecr:GetAuthorizationToken"
                  - "ecr:BatchCheckLayerAvailability"
                  - "ecr:GetDownloadUrlForLayer"
                  - "ecr:BatchGetImage"
                  - "ecr:InitiateLayerUpload"
                  - "ecr:UploadLayerPart"
                  - "ecr:CompleteLayerUpload"
                  - "ecr:PutImage"
                  - "ecr:CreatePullThroughCacheRule"
                  - "ecr:BatchImportUpstreamImage"
                  - "ecr:CreateRepository"
                resources:
                  - "*"
              AllowAssumeRole:
                effect: "Allow"
                actions:
                  - "sts:AssumeRole"
                  - "sts:TagSession"
                  - "sts:SetSourceIdentity"
                resources:
                  - "*"
              AllowServicesAccess:
                effect: "Allow"
                actions:
                  - "s3:*"
                  - "iam:*"
                  - "ecs:*"
                  - "ecr:*"
                  - "logs:*"
                  - "ssm:*"
                  - "ec2:*"
                  - "elasticloadbalancing:*"
                  - "application-autoscaling:*"
                  - "cloudwatch:*"
                  - "kms:Decrypt"
                resources:
                  - "*"
    ```

    ```bash
    atmos terraform deploy example-app/iam-role -s plat-gbl-dev
    atmos terraform deploy example-app/iam-role -s plat-gbl-staging
    atmos terraform deploy example-app/iam-role -s plat-gbl-prod
    ```
  </Step>

  <Step>
    ### <StepNumber/> Update tfstate-bucket-app Access

    Grant the newly created IAM roles access to the Terraform state bucket.

    Add the IAM role ARN references to your tfstate backend configuration:

    ```yaml title="stacks/catalog/tfstate-backend/apps.yaml"
    components:
      terraform:
        tfstate-backend-apps:
          vars:
            privileged_principal_arns:
              - !terraform.state example-app/iam-role .role.arn
    ```

    ```bash
    atmos terraform deploy tfstate-backend-apps -s plat-gbl-dev
    atmos terraform deploy tfstate-backend-apps -s plat-gbl-staging
    atmos terraform deploy tfstate-backend-apps -s plat-gbl-prod
    ```
  </Step>

  <Step>
    ### <StepNumber/> Update profiles/github

    Configure the app repository with the IAM roles provisioned in the previous steps.

    In your **application repository**, update the Atmos auth configuration with the provisioned IAM roles:

    ```yaml title="profiles/github/atmos.yaml"
    # ...

    auth:
      providers:
        github-oidc:
          kind: github/oidc
          region: us-west-1
          spec:
            audience: sts.amazonaws.com

      identities:
        plat-dev/terraform:
          kind: aws/assume-role
          via:
            provider: github-oidc
          principal:
            assume_role: arn:aws:iam::111111111111:role/acme-plat-gbl-dev-example-app-terraform

        plat-staging/terraform:
          kind: aws/assume-role
          via:
            provider: github-oidc
          principal:
            assume_role: arn:aws:iam::222222222222:role/acme-plat-gbl-dev-example-app-terraform

        plat-prod/terraform:
          kind: aws/assume-role
          via:
            provider: github-oidc
          principal:
            assume_role: arn:aws:iam::333333333333:role/acme-plat-gbl-dev-example-app-terraform
    ```

    <Admonition type="tip" title="IAM Role ARNs">
      Get the role ARNs from the outputs of the IAM role deployments in step 5:
      ```bash
      atmos terraform output example-app/iam-role -s plat-gbl-dev -- -raw role_arn
      ```
    </Admonition>
  </Step>

  <Step>
    ### <StepNumber/> Configure GitHub Repository

    Add repository `ECR_REGISTRY` variable required by the GitHub Actions workflows.

    <Steps>
      1. Navigate to your repository → Settings → Secrets and variables → Actions
      2. Click the "Variables" tab
      3. Click "New repository variable"
      4. Add the following variable:

         | Name | Value |
         |------|-------|
         | `ECR_REGISTRY` | Your ECR registry URL (e.g., `444444444444.dkr.ecr.us-east-1.amazonaws.com`) |
    </Steps>

    <Admonition type="tip" title="Organization Variables">
      If you have multiple application repositories, consider creating an organization-level variable for `ECR_REGISTRY` to avoid repetition.
    </Admonition>
  </Step>

  <Step>
    ### <StepNumber/> Provision Shared Dependencies

    Deploy application dependencies that have a different lifecycle than the application itself (e.g., databases, message queues, caches).

    <Admonition type="info" title="Optional Step">
      Skip this step if your application doesn't require external dependencies like databases or caches.
    </Admonition>
  </Step>

  <Step>
    ### <StepNumber/> Configure Dependencies

    Configure the application to read from infrastructure components' remote state.

    In your **application repository**, create dependency stack files:

    ```yaml title="terraform/stacks/deps/vpc.yaml"
    components:
      terraform:
        vpc:
          metadata:
            component: vpc
            type: abstract
            terraform_workspace: "{{ .vars.tenant }}-{{ .vars.environment }}-{{ .vars.deps_stage }}"
          backend_type: s3
          backend:
            s3:
              bucket: "acme-core-gbl-root-tfstate"
              region: "us-east-1"
              encrypt: true
              key: terraform.tfstate
              acl: bucket-owner-full-control
              assume_role:
                role_arn: "arn:aws:iam::111111111111:role/acme-core-gbl-root-tfstate-ro"
    ```

    ```yaml title="terraform/stacks/deps/ecs-cluster.yaml"
    components:
      terraform:
        vpc:
          metadata:
            component: vpc
            type: abstract
            terraform_workspace: "{{ .vars.tenant }}-{{ .vars.environment }}-{{ .vars.deps_stage }}"
          backend_type: s3
          backend:
            s3:
              bucket: "acme-core-gbl-root-tfstate"
              region: "us-east-1"
              encrypt: true
              key: terraform.tfstate
              acl: bucket-owner-full-control
              assume_role:
                role_arn: "arn:aws:iam::111111111111:role/acme-core-gbl-root-tfstate-ro"
    ```

    And any other external dependencies like databases or caches.
  </Step>

  <Step>
    ### <StepNumber/> Configure Container Definitions

    Define the ECS task and container settings for your application.

    ```yaml title="terraform/stacks/default/app.yaml"
    components:
      terraform:
        app:
          vars:
            desired_count: 1
            cpu: 256
            memory: 512
            container_definitions:
              app:
                image: !env APP_IMAGE
                port_mappings:
                  - containerPort: 8080
                    hostPort: 8080
                    protocol: "tcp"
                environment:
                  - name: "APP_ENV"
                    value: "production"
                secrets:
                  - name: "DATABASE_URL"
                    valueFrom: !terraform.state rds .database_url
    ```

    And/or update Terraform component (if needed). Modify the ECS task component in `terraform/components/ecs-task/` to match your application requirements:

    - Add additional IAM permissions
    - Configure health check settings
    - Set up log configuration
    - Add sidecar containers
  </Step>

  <Step>
    ### <StepNumber/> Test Configuration

    Verify the Atmos configuration works correctly.

    ```bash
    atmos terraform plan app -s preview
    ```

    Check that:
    - All remote state references resolve correctly
    - Container definitions are valid
    - IAM roles and permissions are configured
    - No errors in the plan output
  </Step>
</Steps>

## Quick Checklist

<TaskList>
- [ ] Platform infrastructure deployed (VPC, ECS cluster, GitHub OIDC Provider)
- [ ] `tfstate-bucket-apps` provisioned in dev/staging/prod
- [ ] Application repository created from template
- [ ] ECR registry provisioned (`core-use1-artifacts`)
- [ ] IAM roles provisioned in dev/staging/prod
- [ ] `tfstate-backend-apps` updated with IAM role access
- [ ] `profiles/github/atmos.yaml` configured with IAM role ARNs
- [ ] GitHub repo variable `ECR_REGISTRY` configured
- [ ] Shared dependencies provisioned (if applicable)
- [ ] Dependencies configured in `terraform/stacks/deps/`
- [ ] Container definitions configured in `terraform/stacks/default/app.yaml`
- [ ] `atmos terraform plan app -s preview` runs successfully
</TaskList>

---

## Triggering Workflows

Once setup is complete, validate the workflows:

<Steps>
  <Step>
    ### <StepNumber/> Create a Pull Request

    Create a PR and add the `deploy` label to deploy a preview environment:

    ```bash
    git checkout -b feature/test-preview
    # Make changes
    git push origin feature/test-preview
    ```

    Then add the `deploy` label to the PR in GitHub.
  </Step>

  <Step>
    ### <StepNumber/> Merge PR into Main Branch

    Push any change to the `main` branch to trigger the main branch workflow:

    ```bash
    git add .
    git commit -m "Initial setup"
    git push origin main
    ```

    This will:
    - Build and push a Docker image to ECR
    - Deploy to the `dev` environment
    - Create a draft release
  </Step>


  <Step>
    ### <StepNumber/> Publish a Release

    Edit the draft release created by the main branch workflow and click "Publish release". This will:
    - Promote the Docker image tag
    - Deploy to `staging`
    - Wait for approval (if configured)
    - Deploy to `prod`
  </Step>
</Steps>

---

## References

- [app-on-ecs-v2](https://github.com/cloudposse-examples/app-on-ecs-v2): Example application repository
- [Atmos](https://atmos.tools): Configuration orchestration tool
- [OpenTofu](https://opentofu.org): Infrastructure-as-code tool
- [GitHub OIDC with AWS](/layers/github-actions/github-oidc-with-aws): How to configure GitHub OIDC
- [github-action-docker-build-push](https://github.com/cloudposse/github-action-docker-build-push): Docker build action
