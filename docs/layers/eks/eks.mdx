---
title: "EKS Foundational Platform"
sidebar_label: "EKS"
sidebar_class_name: hidden
---
import Intro from '@site/src/components/Intro';
import KeyPoints from '@site/src/components/KeyPoints';

Amazon EKS is a managed Kubernetes service to run Kubernetes in the AWS cloud and on-premises data centers. In the
cloud, Amazon EKS automatically manages the availability and scalability of the Kubernetes control plane nodes
responsible for scheduling containers, managing application availability, storing cluster data, and other key tasks.
With Amazon EKS, you can take advantage of all the performance, scale, reliability, and availability of AWS
infrastructure, as well as integrations with AWS networking and security services. On-premises, EKS provides a
consistent, fully-supported Kubernetes solution with integrated tooling and simple deployment to AWS Outposts, virtual
machines, or bare metal servers.

## The Problem

Although Amazon EKS is a managed service, there is still much that is needed to set up any given cluster. First of all,
we must decide how we want to deploy Nodes for the cluster. EC2 instance backed nodes, Amazon Fargate, or Karpenter all
provide solutions for the foundation of a cluster. Next we must provide a method to authenticate with the cluster.
Amazon IAM roles can grant API access to the EKS service but do not grant control within Kubernetes. Kubernetes system
roles are native to the cluster, but we need to be able to scope finer access of users and resources than what is
provided natively. Furthermore, we need to connect each cluster to our network and DNS architecture. Clusters must be
secure and protected from the public internet, yet developers still need to be able to connect and manage cluster
resources. And finally, we need a place to storage application data.

## Our Solution

Cloud Posse deploys EKS through a number of components. Each component has a specific responsibility and works in
harmony with the rest. We first deploy a nodeless EKS cluster and create an AWS Auth config mapping. This `ConfigMap`
connects our existing AWS Teams architecture to the cluster and allows us to assign Kubernetes roles to a given Team
Role. Next we use Karpenter to manage nodes on the cluster. Karpenter automatically launches compute resources to handle
cluster applications and provides fast and simple compute provisioning for Kubernetes clusters. We then deploy a set of
controllers and operators for the cluster. These controllers will automatically connect the cluster to our network and
DNS architecture by annotations and manage storage within the cluster. Simply adding the relevant annotation to a given
resources triggers the creation and management of Load Balancers in AWS, adds routing to the relevant Route 53 Hosted
Zone, provisions certificates, and more. These resources set the foundation for any application platform. From this
foundation, your application will be fully secure, scalable, and resilient.

## References

- [Decide on EKS Node Pool Architecture](/reference-architecture/fundamentals/design-decisions/foundational-platform/decide-on-eks-node-pool-architecture/)
- [Decide on Kubernetes Ingress Controller(s)](/reference-architecture/fundamentals/design-decisions/foundational-platform/decide-on-kubernetes-ingress-controller-s/)
- [How to Load Test in AWS](/learn/maintenance/tutorials/how-to-load-test-in-aws)
- [How to Tune EKS with AWS Managed Node Groups](/reference-architecture/how-to-guides/tutorials/how-to-tune-eks-with-aws-managed-node-groups/)
- [How to Keep Everything Up to Date](/learn/maintenance/upgrades/how-to-keep-everything-up-to-date)
- [How to Tune SpotInst Parameters for EKS](/resources/legacy/spotinst/how-to-tune-spotinst-parameters-for-eks)
- [How to Upgrade EKS Cluster Addons](/learn/maintenance/upgrades/how-to-upgrade-eks-cluster-addons)
- [How to Upgrade EKS](/learn/maintenance/upgrades/how-to-upgrade-eks)

## FAQ

### How can I create secrets for an EKS cluster?

Consider deploying the [`external-secrets-operator` component](/components/library/aws/eks/external-secrets-operator).

This component creates an external SecretStore configured to synchronize secrets from AWS SSM Parameter store as
Kubernetes Secrets within the cluster. Per the operator pattern, the `external-secret-operator` pods will watch for any
ExternalSecret resources which reference the SecretStore to pull secrets from.

### How does the `alb-controller-ingress-group` determine the name of the ALB?

1. First the component uses null label to generate our intended name. We do this to meet the character length
   restrictions on ALB names.
   [ref](https://github.com/cloudposse/terraform-aws-components/blob/master/modules/eks/alb-controller-ingress-group/main.tf#L75-L83)
2. Then we pass that output to the Kubernetes Ingress resource with an annotation intended to define the ALB's name.
   [ref](https://github.com/cloudposse/terraform-aws-components/blob/master/modules/eks/alb-controller-ingress-group/main.tf#L98)
3. Now the Ingress is created and `alb-controller` creates an ALB using the annotations on that `Ingress`. This ALB name
   will have a dynamic character sequence at the end of it, so we cannot know what the name will be ahead of time.
4. Finally, we grab the actual name that is given to the created ALB with the `data.aws_lb` resources.
   [ref](https://github.com/cloudposse/terraform-aws-components/blob/master/modules/eks/alb-controller-ingress-group/main.tf#L169)
5. Then output that name for future reference.
   [ref](https://github.com/cloudposse/terraform-aws-components/blob/master/modules/eks/alb-controller-ingress-group/main.tf#L36)

### How can we create Self Hosted Runners for GitHub with EKS?

Self-Hosted Runners are a great way to save cost and add customizations with GitHub Actions. Since we've already
implemented EKS for our platform, we can build off that foundation to create another cluster to manage Self-Hosted
runners in GitHub. We deploy that new EKS cluster to `core-auto` and install the
[Actions Runner Controller (ARC) chart](https://github.com/actions/actions-runner-controller). This controller will
launch and scale runners for GitHub automatically.

For more on how to set up ARC, see the
[GitHub Action Runners setup docs for EKS](/reference-architecture/setup/github-actions-runners/).
